# Effective-Java
이펙티브 자바  
죠슈아 블로크  
![](https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9788966262281.jpg)

## 스터디 기간
'25.07.24 ~

## 스터디원
<table>
  <tr>
  <td align="center"><a href="https://github.com/Pearl-K"><img src="https://avatars.githubusercontent.com/u/80253713?v=4" width="100px;" alt=""/><br />
      <br /><sub><b>강진주</b></sub></a></td>

  <td align="center"><a href="https://github.com/column-wise"><img src="https://avatars.githubusercontent.com/u/61263933?v=4" width="100px;" alt=""/><br />
      <br /><sub><b>이주현</b></sub></a></td>
    
  <td align="center"><a href="https://github.com/hyein0229"><img src="https://avatars.githubusercontent.com/u/85734016?v=4" width="100px;" alt=""/><br />
      <br /><sub><b>이혜인</b></sub></a></td>
  </tr>
</table>

## 목차

| 장 | 아이템 | 제목 |
|---|---|---|
| 1장 | - | 들어가기 |
| 2장 | - | **객체 생성과 파괴** |
| | [1](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter2(객체생성과파괴)/item1.md) | 생성자 대신 정적 팩터리 메서드를 고려하라 |
| | [2](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter2(객체생성과파괴)/item2.md) | 생성자에 매개변수가 많다면 빌더를 고려하라 |
| | [3](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter2(객체생성과파괴)/item3.md) | private 생성자나 열거 타입으로 싱글턴임을 보증하라 |
| | [4](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter2(객체생성과파괴)/item4.md) | 인스턴스화를 막으려거든 private 생성자를 사용하라 |
| | [5](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter2(객체생성과파괴)/item5.md) | 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라 |
| | [6](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter2(객체생성과파괴)/item6.md) | 불필요한 객체 생성을 피하라 |
| | [7](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter2(객체생성과파괴)/item7.md) | 다 쓴 객체 참조를 해제하라 |
| | [8](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter2(객체생성과파괴)/item8.md) | finalizer와 cleaner 사용을 피하라 |
| | [9](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter2(객체생성과파괴)/item9.md) | try-finally보다는 try-with-resources를 사용하라 |
| 3장 | - | **모든 객체의 공통 메서드** |
| | [10](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter3(모든객체의공통메서드)/item10.md) | equals는 일반 규약을 지켜 재정의하라 |
| | [11](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter3(모든객체의공통메서드)/item11.md) | equals를 재정의하려거든 hashCode도 재정의하라 |
| | [12](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter3(모든객체의공통메서드)/item12.md) | toString을 항상 재정의하라 |
| | [13](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter3(모든객체의공통메서드)/item13.md) | clone 재정의는 주의해서 진행하라 |
| | [14](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter3(모든객체의공통메서드)/item14.md) | Comparable을 구현할지 고려하라 |
| 4장 | - | **클래스와 인터페이스** |
| | [15](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter4(클래스와인터페이스)/item15.md) | 클래스와 멤버의 접근 권한을 최소화하라 |
| | [16](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter4(클래스와인터페이스)/item16.md) | public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라 |
| | [17](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter4(클래스와인터페이스)/item17.md) | 변경 가능성을 최소화하라 |
| | [18](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter4(클래스와인터페이스)/item18.md) | 상속보다는 컴포지션을 사용하라 |
| | [19](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter4(클래스와인터페이스)/item19.md) | 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라 |
| | [20](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter4(클래스와인터페이스)/item20.md) | 추상 클래스보다는 인터페이스를 우선하라 |
| | [21](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter4(클래스와인터페이스)/item21.md) | 인터페이스는 구현하는 쪽을 생각해 설계하라 |
| | [22](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter4(클래스와인터페이스)/item22.md) | 인터페이스는 타입을 정의하는 용도로만 사용하라 |
| | [23](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter4(클래스와인터페이스)/item23.md) | 태그 달린 클래스보다는 클래스 계층구조를 활용하라 |
| | [24](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter4(클래스와인터페이스)/item24.md) | 멤버 클래스는 되도록 static으로 만들라 |
| | [25](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter4(클래스와인터페이스)/item25.md) | 톱레벨 클래스는 한 파일에 하나만 담으라 |
| 5장 | - | **제네릭** |
| | [26](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter5(제네릭)/item26.md) | 로 타입은 사용하지 말라 |
| | [27](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter5(제네릭)/item27.md) | 비검사 경고를 제거하라 |
| | [28](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter5(제네릭)/item28.md) | 배열보다는 리스트를 사용하라 |
| | [29](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter5(제네릭)/item29.md) | 이왕이면 제네릭 타입으로 만들라 |
| | [30](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter5(제네릭)/item30.md) | 이왕이면 제네릭 메서드로 만들라 |
| | [31](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter5(제네릭)/item31.md) | 한정적 와일드카드를 사용해 API 유연성을 높이라 |
| | [32](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter5(제네릭)/item32.md) | 제네릭과 가변인수를 함께 쓸 때는 신중하라 |
| | [33](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter5(제네릭)/item33.md) | 타입 안전 이종 컨테이너를 고려하라 |
| 6장 | - | **열거 타입과 애너테이션** |
| | [34](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter6(열거타입과애노테이션)/item34.md) | int 상수 대신 열거 타입을 사용하라 |
| | [35](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter6(열거타입과애노테이션)/item35.md) | ordinal 메서드 대신 인스턴스 필드를 사용하라 |
| | [36](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter6(열거타입과애노테이션)/item36.md) | 비트 필드 대신 EnumSet을 사용하라 |
| | [37](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter6(열거타입과애노테이션)/item37.md) | ordinal 인덱싱 대신 EnumMap을 사용하라 |
| | [38](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter6(열거타입과애노테이션)/item38.md) | 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라 |
| | [39](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter6(열거타입과애노테이션)/item39.md) | 명명 패턴보다 애너테이션을 사용하라 |
| | [40](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter6(열거타입과애노테이션)/item40.md) | @Override 애너테이션을 일관되게 사용하라 |
| | [41](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter6(열거타입과애노테이션)/item41.md) | 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라 |
| 7장 | - | **람다와 스트림** |
| | [42](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter7(람다와스트림)/item42.md) | 익명 클래스보다는 람다를 사용하라 |
| | [43](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter7(람다와스트림)/item43.md) | 람다보다는 메서드 참조를 사용하라 |
| | [44](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter7(람다와스트림)/item44.md) | 표준 함수형 인터페이스를 사용하라 |
| | [45](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter7(람다와스트림)/item45.md) | 스트림은 주의해서 사용하라 |
| | [46](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter7(람다와스트림)/item46.md) | 스트림에서는 부작용 없는 함수를 사용하라 |
| | [47](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter7(람다와스트림)/item47.md) | 반환 타입으로는 스트림보다 컬렉션이 낫다 |
| | [48](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter7(람다와스트림)/item48.md) | 스트림 병렬화는 주의해서 적용하라 |
| 8장 | - | **메서드** |
| | [49](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter8(메서드)/item49.md) | 매개변수가 유효한지 검사하라 |
| | [50](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter8(메서드)/item50.md) | 적시에 방어적 복사본을 만들라 |
| | [51](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter8(메서드)/item51.md) | 메서드 시그니처를 신중히 설계하라 |
| | [52](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter8(메서드)/item52.md) | 다중정의는 신중히 사용하라 |
| | [53](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter8(메서드)/item53.md) | 가변인수는 신중히 사용하라 |
| | [54](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter8(메서드)/item54.md) | null이 아닌, 빈 컬렉션이나 배열을 반환하라 |
| | [55](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter8(메서드)/item55.md) | 옵셔널 반환은 신중히 하라 |
| | [56](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter8(메서드)/item56.md) | 공개된 API 요소에는 항상 문서화 주석을 작성하라 |
| 9장 | - | **일반적인 프로그래밍 원칙** |
| | [57](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item57.md) | 지역변수의 범위를 최소화하라 |
| | [58](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item58.md) | 전통적인 for 문보다는 for-each 문을 사용하라 |
| | [59](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item59.md) | 라이브러리를 익히고 사용하라 |
| | [60](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item60.md) | 정확한 답이 필요하다면 float와 double은 피하라 |
| | [61](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item61.md) | 박싱된 기본 타입보다는 기본 타입을 사용하라 |
| | [62](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item62.md) | 다른 타입이 적절하다면 문자열 사용을 피하라 |
| | [63](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item63.md) | 문자열 연결은 느리니 주의하라 |
| | [64](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item64.md) | 객체는 인터페이스를 사용해 참조하라 |
| | [65](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item65.md) | 리플렉션보다는 인터페이스를 사용하라 |
| | [66](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item66.md) | 네이티브 메서드는 신중히 사용하라 |
| | [67](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item67.md) | 최적화는 신중히 하라 |
| | [68](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter9(일반적인프로그래밍원칙)/item68.md) | 일반적으로 통용되는 명명 규칙을 따르라 |
| 10장 | - | **예외** |
| | [69](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter10(예외)/item69.md) | 예외는 진짜 예외 상황에만 사용하라 |
| | [70](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter10(예외)/item70.md) | 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라 |
| | [71](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter10(예외)/item71.md) | 필요 없는 검사 예외 사용은 피하라 |
| | [72](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter10(예외)/item72.md) | 표준 예외를 사용하라 |
| | [73](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter10(예외)/item73.md) | 추상화 수준에 맞는 예외를 던지라 |
| | [74](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter10(예외)/item74.md) | 메서드가 던지는 모든 예외를 문서화하라 |
| | [75](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter10(예외)/item75.md) | 예외의 상세 메시지에 실패 관련 정보를 담으라 |
| | [76](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter10(예외)/item76.md) | 가능한 한 실패 원자적으로 만들라 |
| | [77](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter10(예외)/item77.md) | 예외를 무시하지 말라 |
| 11장 | - | **동시성** |
| | [78](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter11(동시성)/item78.md) | 공유 중인 가변 데이터는 동기화해 사용하라 |
| | [79](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter11(동시성)/item79.md) | 과도한 동기화는 피하라 |
| | [80](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter11(동시성)/item80.md) | 스레드보다는 실행자, 태스크, 스트림을 애용하라 |
| | [81](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter11(동시성)/item81.md) | wait와 notify보다는 동시성 유틸리티를 애용하라 |
| | [82](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter11(동시성)/item82.md) | 스레드 안전성 수준을 문서화하라 |
| | [83](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter11(동시성)/item83.md) | 지연 초기화는 신중히 사용하라 |
| | [84](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter11(동시성)/item84.md) | 프로그램의 동작을 스레드 스케줄러에 기대지 말라 |
| 12장 | - | **직렬화** |
| | [85](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter12(직렬화)/item85.md) | 자바 직렬화의 대안을 찾으라 |
| | [86](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter12(직렬화)/item86.md) | Serializable을 구현할지는 신중히 결정하라 |
| | [87](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter12(직렬화)/item87.md) | 커스텀 직렬화 형태를 고려해보라 |
| | [88](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter12(직렬화)/item88.md) | readObject 메서드는 방어적으로 작성하라 |
| | [89](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter12(직렬화)/item89.md) | 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라 |
| | [90](https://github.com/Dev-Book-Shelf/Effective-Java/blob/main/chapter12(직렬화)/item90.md) | 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라 |
